<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on Blog</title>
    <link>https://xcr0.github.io/notes/</link>
    <description>Recent content in Notes on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>@ xcr0</copyright>
    <lastBuildDate>Tue, 18 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://xcr0.github.io/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>category theory notes</title>
      <link>https://xcr0.github.io/notes/category/</link>
      <pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://xcr0.github.io/notes/category/</guid>
      <description></description>
      <content></content>
    </item>
    
    <item>
      <title>computability theory notes</title>
      <link>https://xcr0.github.io/notes/computability/</link>
      <pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://xcr0.github.io/notes/computability/</guid>
      <description></description>
      <content></content>
    </item>
    
    <item>
      <title>haskell notes</title>
      <link>https://xcr0.github.io/notes/haskell/</link>
      <pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://xcr0.github.io/notes/haskell/</guid>
      <description>preface haskell is a statically typed pure functional programming language which is deeply rooted within category theory. the term &amp;lsquo;pure&amp;rsquo; in this instance relates to the fact that the language itself does not inherently support side effects.
within imperative languages, you can declare variables which hold state within the program. this state can be affected by any function within the program as long as it resides within scope. as a result of this, if a function modifies any form of state whilst its executing, then it cannot be regarded as a free function.</description>
      <content>&lt;h2 id=&#34;preface&#34;&gt;preface&lt;/h2&gt;
&lt;p&gt;haskell is a statically typed pure functional programming language which is deeply
rooted within category theory. the term &amp;lsquo;pure&amp;rsquo; in this instance relates to the fact
that the language itself does not inherently support side effects.&lt;/p&gt;
&lt;p&gt;within imperative languages, you can declare variables which hold state within
the program. this state can be affected by any function within the program as
long as it resides within scope. as a result of this, if a function modifies
any form of state whilst its executing, then it cannot be regarded as a free
function.&lt;/p&gt;
&lt;p&gt;this is not the case for haskell, as expressions within haskell may not explicitly
modify state (without trickery); thereby making haskell pure.&lt;/p&gt;
&lt;p&gt;as all languages need some form of achieving I/O, haskell uses the IO action, which
is a monad which acts as an object that encapsulates a channel between the pure
program and the real world.&lt;/p&gt;
&lt;p&gt;haskell is also statically and strongly typed, meaning that statically (types are
declared, inferred, and checked at compile time); and strongly (operations between
types are strongly enforced. id est you cannot add an Integer and a Float).&lt;/p&gt;
&lt;p&gt;languages such as c++ and java are also statically typed, with the exception of
integral types, which are typically handled via implicit conversion. as a result,
within c++ we have operator overloading, which allows us to essentially define an
existing method (or operator) for any given type (class).&lt;/p&gt;
&lt;p&gt;in the case of c++, operators are a bit fuzzy. when performing operations on primitive
types such as int, char et cetera, operators are not functions/methods. when applying
&amp;ldquo;operators&amp;rdquo; to classes, the class must first define or overload the operator for
each respective class. in this case, these operators will just be methods with operators
for names.&lt;/p&gt;
&lt;h2 id=&#34;laziness&#34;&gt;laziness&lt;/h2&gt;
&lt;p&gt;another unique feature of haskell is its laziness.&lt;/p&gt;
&lt;h2 id=&#34;polymorphism&#34;&gt;polymorphism&lt;/h2&gt;
&lt;p&gt;parametric and ad-hoc / bounded polymorphism within haskell.&lt;/p&gt;
&lt;h2 id=&#34;functors&#34;&gt;functors&lt;/h2&gt;
&lt;p&gt;next up are functors, this allows for the generic mapping across all data types
(computational contexts) which inherit or define an instance of the functor type
class.&lt;/p&gt;
&lt;p&gt;first, lets map a function over any random list.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-hs&#34; data-lang=&#34;hs&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and that works properly right? well what about when we try mapping over another container?
lets try this on the Maybe data type.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map (+1) (Just 1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;as we can see, this fails, giving us an error which states that the map function
expected a different type. we have a few ways of going about mapping across our Maybe
type now. we could technically just rewrite the map function to map over each
and every single type we declare, but that would be far too tedious. instead, we can
use functors as a generic means of mapping over types.&lt;/p&gt;
&lt;p&gt;the following is the definition of the functor type class.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-hs&#34; data-lang=&#34;hs&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Functor&lt;/span&gt; f &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  fmap &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; f b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- map definition&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- it may help to look at the definition of map, which is a function which only allows us&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;-- to map across lists.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; [b]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;as we can see, the functor typeclass has one method named fmap. lets see an example of
how this may be used within something like the Maybe functor. the first argument for
fmap takes a function which we want to map across the data type (context). in this
case, the function type must be (a -&amp;gt; b), taking one argument of type a and returning a
result of type b.&lt;/p&gt;
&lt;p&gt;the next argument it takes is the an instance of the functor type, or computational
context to apply the function to. and as a result, it returns a new instance of a
functor containing type b.&lt;/p&gt;
&lt;p&gt;looking at the definiton of map, we can draw some similarities. in the case of the
map function, the &amp;ldquo;functor instance&amp;rdquo; or computational context is the list, which
wraps both types of a and b.&lt;/p&gt;
&lt;p&gt;now lets look at the definition for the maybe instance. it will simply overload the
functor method and apply the function with the value inside each context.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-hs&#34; data-lang=&#34;hs&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Functor&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Maybe&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  fmap f &lt;span style=&#34;color:#66d9ef&#34;&gt;Nothing&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Nothing&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  fmap f (&lt;span style=&#34;color:#66d9ef&#34;&gt;Just&lt;/span&gt; x) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Just&lt;/span&gt; (f x)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;lets now put this into practice and write a binary search tree.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-hs&#34; data-lang=&#34;hs&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Tree&lt;/span&gt; a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Node&lt;/span&gt; a (&lt;span style=&#34;color:#66d9ef&#34;&gt;Tree&lt;/span&gt; a) (&lt;span style=&#34;color:#66d9ef&#34;&gt;Tree&lt;/span&gt; a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Leaf&lt;/span&gt; a
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Empty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;Eq&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;Show&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Functor&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Node&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;-- fmap :: (a -&amp;gt; b) -&amp;gt; Node a -&amp;gt; Node b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  fmap f (&lt;span style=&#34;color:#66d9ef&#34;&gt;Node&lt;/span&gt; x l r) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Node&lt;/span&gt; (f x) (fmap f l) (fmap f r)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  fmap f (&lt;span style=&#34;color:#66d9ef&#34;&gt;Leaf&lt;/span&gt; x) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Leaf&lt;/span&gt; (f x)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  fmap &lt;span style=&#34;color:#66d9ef&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Empty&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Empty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;starting off we have defined the type for our tree, as well as the functor
instance. lets now work towards writing actual functions which allow us to
operate on and mutate our tree.&lt;/p&gt;
&lt;p&gt;functor laws.&lt;/p&gt;
&lt;h2 id=&#34;applicative&#34;&gt;applicative&lt;/h2&gt;
&lt;p&gt;applicatives for mapping functions which take more than one argument.&lt;/p&gt;
&lt;p&gt;applicative laws&lt;/p&gt;
&lt;h2 id=&#34;monoid&#34;&gt;monoid&lt;/h2&gt;
&lt;p&gt;associativity and identity&lt;/p&gt;
&lt;p&gt;monoid laws&lt;/p&gt;
&lt;h2 id=&#34;monad&#34;&gt;monad&lt;/h2&gt;
&lt;p&gt;monad laws&lt;/p&gt;
&lt;h2 id=&#34;readerwriter-monads&#34;&gt;reader/writer monads&lt;/h2&gt;
&lt;h2 id=&#34;state-monad&#34;&gt;state monad&lt;/h2&gt;
&lt;h2 id=&#34;monad-transformers&#34;&gt;monad transformers&lt;/h2&gt;
&lt;h2 id=&#34;monadic-parsing&#34;&gt;monadic parsing&lt;/h2&gt;
&lt;h2 id=&#34;zippers&#34;&gt;zippers&lt;/h2&gt;
&lt;h2 id=&#34;lenses&#34;&gt;lenses&lt;/h2&gt;
&lt;h2 id=&#34;comonads&#34;&gt;comonads&lt;/h2&gt;
&lt;h2 id=&#34;continuation-monad&#34;&gt;continuation monad&lt;/h2&gt;
&lt;h2 id=&#34;continuation-passing-style&#34;&gt;continuation passing style&lt;/h2&gt;
&lt;h2 id=&#34;concurrency&#34;&gt;concurrency&lt;/h2&gt;
&lt;h2 id=&#34;generalized-algebraic-data-types&#34;&gt;generalized algebraic data types&lt;/h2&gt;
</content>
    </item>
    
    <item>
      <title>logic notes</title>
      <link>https://xcr0.github.io/notes/logic/</link>
      <pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://xcr0.github.io/notes/logic/</guid>
      <description></description>
      <content></content>
    </item>
    
    <item>
      <title>set theory notes</title>
      <link>https://xcr0.github.io/notes/set/</link>
      <pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://xcr0.github.io/notes/set/</guid>
      <description></description>
      <content></content>
    </item>
    
    <item>
      <title>type theory notes</title>
      <link>https://xcr0.github.io/notes/type/</link>
      <pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://xcr0.github.io/notes/type/</guid>
      <description></description>
      <content></content>
    </item>
    
  </channel>
</rss>
